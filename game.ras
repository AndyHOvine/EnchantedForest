program EnchantedForest;
/*

	Original game created by Fabrizio Caruso as a 10 liner BASIC program.
	https://github.com/Fabrizio-Caruso/CBM-BASIC-10-liners/tree/master/Vic20/EnchantedForest

	This version created by Andy Hewitt - Hewco.uk

*/
var  

@define DEBUG		1


	// Address of bitmap (screen and characters)
	@userdata $1000 $1FFF "Bitmap"


	// I need to save some bytes, I don't use these
	@ignoremethod "init16x8mul"
	@ignoremethod "init16x8div"
	@ignoremethod "init8x8div"
	@ignoremethod "initeightbitmul"
	@ignoremethod "initjoystick"
	@ignoremethod "initmoveto"
	


// -------------------------------------------------------------------------------
// GAME PARAMETERS and CONSTANTS


	// pre-shift sprite address offsets for 8x8 sprites
	const sprHeight:byte = 8;
	
	// an 8x8 sprite needs 2 characters to move smoothly between them
	// Enchanted Forest moves sprites 2 pixels at a time which requires
	// four pre-shifted sprites of two characters each
	
	// side a (left)					side b (middle)	
	const m0a:byte = $0;				const m0b:byte = sprHeight;
	const m1a:byte = m0a+(sprHeight*2);	const m1b:byte = m0b+(sprHeight*2);
	const m2a:byte = m1a+(sprHeight*2);	const m2b:byte = m1b+(sprHeight*2);
	const m3a:byte = m2a+(sprHeight*2);	const m3b:byte = m2b+(sprHeight*2);	
	


	const SUSTAINTIME: byte = 6;  // max length of time for musical note




// -------------------------------------------------------------------------------
// Include Resources
@include "memory.ras"



// -------------------------------------------------------------------------------
// Variables:	(for assignable/changing data, use these addresses)

// Zero Page: 			$35 - $63
// Cassette buffer:		$033C-$03FB (828-1019)


	// game tick counter + 1 per FPS
	ticks : byte at $35; 		// incremented 1 per frame
	oldticks : byte at $3d;

	// player variables
	px, py: byte at $3e;
	pd: byte at $40;
	
	i, j, k, m: byte at $41;

	musTime : byte at $45;
	musDelay : byte at $46;
	musSustain : byte at $47;
	

@startblock $2000 "GAME"
// Data:	(for non-assignable data and lookups)


	// Working Zero Page pointers
	p1, pa, pb, cm, m1, m2 : pointer;


// -------------------------------------------------------------------------------
// look up data
@include "lookup.ras"




// -------------------------------------------------------------------------------
// source files

@include "music.ras"
@include "vbl.ras"
@include "level.ras"
@include "player.ras"






// -------------------------------------------------------------------------------
// **** MAIN PROGRAM ****

begin

	m1 := musCh1;
	//m2 := musCh1;
	musDelay := 5;
	musTime := 0;

	Vbl_Init(); // call before set display mode
	
	vbmSetDisplayMode( 0 );
	vbmclear( 0 );
	vbmClearColor( GREEN );	

	AUX_COLOR_AND_VOLUME := %00000010;
	screen_bg_color := BLACK + SCREEN_BG_BLACK;


	Level_Generate();

	p1 := chrTest;
	for j := 0 to 5 do
	begin
		vbmSetColumn( j );
		for i := 0 to 5 do
		begin
			
			vbmDrawTile( p1 );
			screenmemory := screenmemory + 8;
			p1 := p1 + 8;
		end;
	end;


	pd := 0;
	Player_SetAnimation();

	while (true) offpage do 
	begin
	
		vbmSetPosition2( px, py );
		vbmDrawSprite8E( pa, pb );

		@ifdef DEBUG
		screen_bg_color := BLACK + SCREEN_BG_BLACK;
		@endif
		
		while (ticks = oldticks) do begin end;
		oldticks := ticks;

		@ifdef DEBUG
		screen_bg_color := CYAN + SCREEN_BG_BLACK;
		@endif
		
		vbmSetPosition2( px, py );
		vbmDrawSprite8E( pa, pb );


		if ticks & 1 = 0 then
		begin
			readjoy1();
		
			// force in keyboard
			if getkey() = KEY_I then joy1 := JOY_UP;
			if getkey() = KEY_M then joy1 := JOY_DOWN;
			if getkey() = KEY_J then joy1 := JOY_LEFT;
			if getkey() = KEY_K then joy1 := JOY_RIGHT;

			if (joy1 & JOY_UP) then begin py := py - 2; pd:=4+(py&4)>>1; Player_SetAnimation(); end;
			if (joy1 & JOY_DOWN) then begin py := py + 2; pd:=4+(py&4)>>1; Player_SetAnimation(); end;
			if (joy1 & JOY_LEFT) then begin px := px - 2; pd:=2; Player_SetAnimation(); end;
			if (joy1 & JOY_RIGHT) then begin px := px + 2; pd:=0; Player_SetAnimation(); end;
		
			cm := addresstable(colmem, px>>3, py>>4);
			cm[0] := white;

		end;

		
	end;

end.
