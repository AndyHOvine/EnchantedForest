program EnchantedForest;
/*

	Original game created by Fabrizio Caruso as a 10 liner BASIC program.
	https://github.com/Fabrizio-Caruso/CBM-BASIC-10-liners/tree/master/Vic20/EnchantedForest

	This version created by Andy Hewitt - Hewco.uk	
*/
var  

@define DEBUG		1


	// Address of bitmap (screen and characters)
	@userdata $1000 $1FFF "Bitmap"


	// I need to save some bytes, I don't use these
	@ignoremethod "init16x8mul"
	@ignoremethod "init16x8div"
	@ignoremethod "init8x8div"
	@ignoremethod "initeightbitmul"
	@ignoremethod "initjoystick"
	@ignoremethod "initmoveto"
	


// -------------------------------------------------------------------------------
// GAME PARAMETERS and CONSTANTS


	// pre-shift sprite address offsets for 8x8 sprites
	const sprHeight:byte = 8;
	
	// an 8x8 sprite needs 2 characters to move smoothly between them
	// Enchanted Forest moves sprites 2 pixels at a time which requires
	// four pre-shifted sprites of two characters each
	
	// side a (left)					side b (middle)	
	const m0a:byte = $0;				const m0b:byte = sprHeight;
	const m1a:byte = m0a+(sprHeight*2);	const m1b:byte = m0b+(sprHeight*2);
	const m2a:byte = m1a+(sprHeight*2);	const m2b:byte = m1b+(sprHeight*2);
	const m3a:byte = m2a+(sprHeight*2);	const m3b:byte = m2b+(sprHeight*2);	
	


	const SUSTAINTIME: byte = 6;  // max length of time for musical note



// -------------------------------------------------------------------------------
// Resource memory



// -------------------------------------------------------------------------------
// Include Resources
@vbmexport "spr/sprites.flf" "spr/sprRight.bin" 0 8 1 0			// S E H M
@vbmexport "spr/sprites.flf" "spr/sprLeft.bin" 40 48 1 0		// S E H M
@vbmexport "spr/sprites.flf" "spr/sprVert1.bin" 80 88 1 0		// S E H M
@vbmexport "spr/sprites.flf" "spr/sprVert2.bin" 120 128 1 0		// S E H M
@vbmexport "chr/graphics.flf" "chr/graphics.bin" 0 9 1 0		// S E H M

const aSprRight: address = $3e00;
const aSprLeft:  address = aSprRight + (sprHeight*8);
const aSprVert1: address = aSprLeft + (sprHeight*8);
const aSprVert2: address = aSprVert1 + (sprHeight*8);
const aChrGfx:   address = aSprVert2 + (sprHeight*8);

sprRight: incbin("spr/sprRight.bin", aSprRight);
sprLeft:  incbin("spr/sprLeft.bin", aSprLeft);
sprVert1: incbin("spr/sprVert1.bin", aSprVert1);
sprVert2: incbin("spr/sprVert2.bin", aSprVert2);
chrGfx:   incbin("chr/graphics.bin", aChrGfx);




// -------------------------------------------------------------------------------
// Variables:	(for assignable/changing data, use these addresses)

// Zero Page: 			$35 - $63
// Cassette buffer:		$033C-$03FB (828-1019)


	// game tick counter + 1 per FPS
	ticks : byte at $35; 		// incremented 1 per frame
	oldticks : byte at $3d;

	// player variables
	px, py: byte at $3e;
	pd: byte at $40;
	
	i, j, k, m: byte at $41;

	musTime : byte at $45;
	musDelay : byte at $46;
	musSustain : byte at $47;
	

@startblock $2000 "GAME"
// Data:	(for non-assignable data and lookups)


	// Working Zero Page pointers
	p1, pa, pb, cm, m1, m2 : pointer;



	// ------------- Player sprite look up addresses -------------
	
	// pre-shifted addresses for Player Right - side A
	sprRight_A: array[] of integer = (
		aSprRight+m0a, aSprRight+m1a, aSprRight+m2a, aSprRight+m3a
	);
	// pre-shifted addresses for Player Right - side B
	sprRight_B: array[] of integer = (
		aSprRight+m0b, aSprRight+m1b, aSprRight+m2b, aSprRight+m3b
	);

	// pre-shifted addresses for Player Left - side A
	sprLeft_A: array[] of integer = (
		aSprLeft+m0a, aSprLeft+m1a, aSprLeft+m2a, aSprLeft+m3a
	);
	// pre-shifted addresses for Player Left - side B
	sprLeft_B: array[] of integer = (
		aSprLeft+m0b, aSprLeft+m1b, aSprLeft+m2b, aSprLeft+m3b
	);

	// pre-shifted addresses for Player Vert1 - side A
	sprVert1_A: array[] of integer = (
		aSprVert1+m0a, aSprVert1+m1a, aSprVert1+m2a, aSprVert1+m3a
	);
	// pre-shifted addresses for Player Vert1 - side B
	sprVert1_B: array[] of integer = (
		aSprVert1+m0b, aSprVert1+m1b, aSprVert1+m2b, aSprVert1+m3b
	);
	
	// pre-shifted addresses for Player Vert21 - side A
	sprVert2_A: array[] of integer = (
		aSprVert2+m0a, aSprVert2+m1a, aSprVert2+m2a, aSprVert2+m3a
	);
	// pre-shifted addresses for Player Vert2 - side B
	sprVert2_B: array[] of integer = (
		aSprVert2+m0b, aSprVert2+m1b, aSprVert2+m2b, aSprVert2+m3b
	);
	
	sprDir: array[] of integer = (
		sprRight_A, sprRight_B, sprLeft_A, sprLeft_B,
		sprVert1_A, sprVert1_B, sprVert2_A, sprVert2_B
	);



	// ------------- Colour memory look up addresses -------------

	const acol: address = $9400;
	colmem: array[] of integer = (
		acol, acol + (20*1), acol + (20*2), acol + (20*3), acol + (20*4),
		acol + (20*5), acol + (20*6), acol + (20*7), acol + (20*8), acol + (20*9),
		 acol + (20*10), acol + (20*11)
	);







// -------------------------------------------------------------------------------
// Include files

@include "music.ras"
@include "vbl.ras"
@include "level.ras"
@include "player.ras"






// -------------------------------------------------------------------------------
// **** MAIN PROGRAM ****

begin

	m1 := musCh1;
	//m2 := musCh1;
	musDelay := 5;
	musTime := 0;

	Vbl_Init(); // call before set display mode
	
	vbmSetDisplayMode( 0 );
	vbmclear( 0 );
	vbmClearColor( GREEN );	

	AUX_COLOR_AND_VOLUME := %00000010;
	screen_bg_color := BLACK + SCREEN_BG_BLACK;


	Level_Generate();


	pd := 0;
	Player_SetAnimation();

	while (true) offpage do 
	begin
	

		vbmSetPosition2( px, py );
		vbmDrawSprite8E( pa, pb );

		@ifdef DEBUG
		screen_bg_color := BLACK + SCREEN_BG_BLACK;
		@endif
		
		while (ticks = oldticks) do begin end;
		oldticks := ticks;

		@ifdef DEBUG
		screen_bg_color := CYAN + SCREEN_BG_BLACK;
		@endif
		
		vbmSetPosition2( px, py );
		vbmDrawSprite8E( pa, pb );


		if ticks & 1 = 0 then
		begin
			readjoy1();
		
			// force in keyboard
			if getkey() = KEY_I then joy1 := JOY_UP;
			if getkey() = KEY_M then joy1 := JOY_DOWN;
			if getkey() = KEY_J then joy1 := JOY_LEFT;
			if getkey() = KEY_K then joy1 := JOY_RIGHT;

			if (joy1 & JOY_UP) then begin py := py - 2; pd:=4+(py&4)>>1; Player_SetAnimation(); end;
			if (joy1 & JOY_DOWN) then begin py := py + 2; pd:=4+(py&4)>>1; Player_SetAnimation(); end;
			if (joy1 & JOY_LEFT) then begin px := px - 2; pd:=2; Player_SetAnimation(); end;
			if (joy1 & JOY_RIGHT) then begin px := px + 2; pd:=0; Player_SetAnimation(); end;
		
			cm := addresstable(colmem, px>>3, py>>4);
			cm[0] := white;

		end;

		
	end;

end.
